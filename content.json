{"pages":[],"posts":[{"title":"","text":"142. Linked List Cycle II 给一个链表，返回链表环开始的结点，如果没有环，则返回空。Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1 接上一道题的判断是否有环，如果无则返回空，如果有则计算环入口（此处有图，我还没画） 12345678910111213141516171819202122232425class Solution {public: ListNode *detectCycle(ListNode *head) { if(head == nullptr || head-&gt;next == nullptr) return nullptr; ListNode* fast = head; ListNode* slow = head; while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(slow == fast) { fast = head; while(fast != slow) { fast = fast-&gt;next; slow = slow-&gt;next; } return slow; } } return nullptr; }};","link":"/2019/03/06/Linked List Cycle II/"},{"title":"","text":"21. Merge Two Sorted Lists 合并两个已排序的序列Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 方法是创建一个结点作为dummy结点，比较l1与l2的值，往后推进。牢记判空。 123456789101112131415161718192021222324252627class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1 == nullptr &amp;&amp; l2 == nullptr) return nullptr; ListNode* l = new ListNode(0); ListNode* cur = l; while(l1 != nullptr &amp;&amp; l2 != nullptr) { if(l1-&gt;val&lt;l2-&gt;val) { cur-&gt;next = l1; l1 = l1-&gt;next; } else { cur-&gt;next = l2; l2 = l2-&gt;next; } cur = cur-&gt;next; } if(l1 == nullptr) cur-&gt;next = l2; if(l2 == nullptr) cur-&gt;next = l1; return l-&gt;next; }};","link":"/2019/03/06/Merge Two Sorted Lists/"},{"title":"","text":"82.Remove Duplicates from Sorted List 在一个已排序的链表中，删除掉所有重复数字。Input: 1-&gt;1-&gt;1-&gt;2-&gt;3Output: 2-&gt;3 这道题，主要是要删除所有的重复数字，就需要一个pre前结点，和一个cur，还有一个next指向结束重复的结点。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if(head == nullptr) return head; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* pre = dummy; ListNode* cur = head; ListNode* nextNode = head; while(cur != nullptr &amp;&amp; cur-&gt;next != nullptr) { nextNode = cur-&gt;next; while(cur != nullptr &amp;&amp; cur-&gt;next != nullptr &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) { nextNode = nextNode-&gt;next; cur = cur-&gt;next; } if(nextNode != pre-&gt;next-&gt;next) { pre-&gt;next = nextNode; cur = nextNode; } else { pre = pre-&gt;next; cur = cur-&gt;next; } } return dummy-&gt;next; }};","link":"/2019/03/06/Remove Duplicates from Sorted List/"},{"title":"","text":"206. Reverse Linked List 翻转链表，经典题Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL （此处有图，我还没画） 123456789101112131415class Solution {public: ListNode* reverseList(ListNode* head) { if(head==nullptr) return nullptr; ListNode* cur = head; ListNode* temp; while(cur-&gt;next!=nullptr) { temp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; temp-&gt;next = head; head = temp; } return head; }};","link":"/2019/03/06/Reverse Linked List/"},{"title":"algothm","text":"","link":"/2019/03/06/algothm/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/06/hello-world/"}],"tags":[],"categories":[]}